#+TITLE: Go Notes
#+AUTHOR: Julio C. Villasante
#+EMAIL: jvillasantegomez@gmail.com
#+DATE: 2015
#+LANGUAGE: en

#+OPTIONS: H:4 num:3 toc:2
#+STARTUP: indent showall align

* Packages
- fmt           :: Provides functions for formatting text and for reading formatted text.
- log           :: Provides logging functions.
- os            :: Provides platform-independent operating-system variables and functions including the
                   os.Args variable of type []string (slice of strings) that holds the command-line arguments.
- strings       :: Provides functions for manipulating strings.
- path/filepath :: Provides functions for manipulating filenames and paths that work across platforms.
- bufio         :: Provides functions for buffered I/O, including ones for reading and writing strings from
                   and to UTF-8 encoded text files.
- io            :: Provides low-level I/O functions - and the io.Reader and io.Writer interfaces.
- io/ioutil     :: Provides high-level file handling functions.
- regexp        :: Provides powerful regular expression support.
- math          :: Provides mathematical functions for operating on floating-point numbers.
- runtime       :: Provides functions that access the program's runtime properties, such as which platform
                   the program is running on.


* Introduction
Go is quite C-like in spirit, being a small and efficient language with convenient low-level facilities such
as pointers. Yet Go also offers many features associated with high - or very high - level languages, such as
Unicode strings, powerful builtin data structures, duck typing, garbage collection, and high-level concurrency
support that uses communication rather than shared data and locks. Go also has a large and wide-ranging
standard library.

** Go's Keywords
break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var

** Go's Predefined Identifiers
append      copy     int8   nil      true
bool        delete   int16  panic    uint
byte        error    int32  print    uint8
cap         false    int64  println  uint16
close       float32  ioat   real     uint32
complex     float64  len    recover  uint64
complex64   imag     make   rune     uintptr
complex128  int      new    string   _

* ch01 - An Overview in Five Examples
Five explained examples.

* ch02 - Booleans and Numbers
** Go's Integer Types and Ranges
| Types   | Range                                                      |
|---------+------------------------------------------------------------|
| byte    | Synonym for uint8                                          |
| int     | The int32 or int64 range depending on the implementation   |
| int8    | [-128, 127]                                                |
| int16   | [−32 768, 32 767]                                          |
| int32   | [−2 147 483 648, 2 147 483 647]                            |
| int64   | [−9 223 372 036 854 775 808, 9 223 372 036 854 775 807]    |
| rune    | Synonym for int32                                          |
| uint    | The uint32 or uint64 range depending on the implementation |
| uint8   | [0, 255]                                                   |
| uint16  | [0, 65 535]                                                |
| uint32  | [0, 4 294 967 295]                                         |
| uint64  | [0, 18 446 744 073 709 551 615]                            |
| uintptr | An unsigned integer capable of storing a pointer value     |


* ch03 - Strings

* ch04 - Collection Types

* ch05 - Procedural Programming

* ch06 - Object-Oriented Programming
An interface data field is in effect a *pointer to an item* - of any kind - that satisfies the interface,
i.e., that has the methods the interface specifies.

* ch07 - Concurrent Programming
The go way to do concurrency is to *communicate* data, not to share data. This makes it much easier to
write concurrent programs than using the traditional threads and locks approach, since with no shared
data we can't get race conditions (such as deadlocks), and we don't have to remember to lock or unlock
since there is no shared data to protect.

A go statement is given a function call, which is executed in a separate asynchronous goroutine.

Channels are modeled on Unix pipes and provide two-way (or at our option, one-way) communication of data items.
Channels behave like FIFO (first in, first out) queues, hence they preserve the order of the items that are sent
into them. Items cannot be dropped from a channel, but we are free to ignore any or all of the items we receive.
If a channel's buffer is filled it blocks until at least one item is received from it. This means that any number
of items can pass through a channel, providing the items are retrieved to make room for subsequent items. A channel
with a buffer size of 0 can only send an item if the other end is waiting for an item. (It is also possible to get
the effect of nonblocking channels using Go's *select* statement). Normally channels are created to provide
communication between goroutines. Channel sends and receives don't need locks, and the channel blocking behaviour
can be used to achieve synchronization.

When the <- communication operator is used as a binary operator its left-hand operand must be a channel and its
right-hand operand must be a value to send to the channel of the type the channel was declared with. When the <-
communication operator is used as a unary operator with just a right-hand operand (which must be a channel), it
acts as a receiver, blocking until it has a value to return.

* ch08 - File Handling

* ch09 - Packages

* Appendix A. Epilogue

* Appendix B. The Dangers of Software Patents

* Appendix C. Selected Bibliography
